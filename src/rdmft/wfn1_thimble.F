c-----------------------------------------------------------------------
c
!> Using Maxima to generate the thimble function and it's derivatives.
!>
!> This code was generated by running the following script throught
!> Maxima using the command line:
!>
!>    maxima -b thimble.mac
!> 
!> The content of thimble.mac is:
!>
!> optimprefix: t;
!> 
!> fortran_block(l,e) := block( [n : 0],
!>   for n:1 thru length(e) do
!>     fortran(l[n] = l[n] + e[n])
!>   );
!> 
!> fortran_optimize(l,e) := block(
!>   for p in rest(args(optimize(e))) do
!>     if op(p)=":" then fortran(apply("=",args(p)))
!>     else if listp(p) then fortran_block(l,p)
!>     else fortran(p)
!>   );
!> 
!> g(r,a,y,z):=(((r+a)**y-a**y)/((1.0+a)**y-a**y))**z;
!> f1(r,a,y,z):=((g(r,a,y,1.0)*log(g(r,a,y,1.0))+g(1.0-r,a,y,1.0)*log(g(1.0-r,a,y,1.0)))/(2.0*g(0.5,a,y,1.0)*log(g(0.5,a,y,1.0))))**z;
!> f2(r1,r2,a,y,z):=((g(r1,a,y,1.0)*g(r2,a,y,1.0)*log(g(r1,a,y,1.0)*g(r2,a,y,1.0))+g(r1,a,y,1.0)*g(1.0-r2,a,y,1.0)*log(g(r1,a,y,1.0)*g(1.0-r2,a,y,1.0))+g(1.0-r1,a,y,1.0)*g(r2,a,y,1.0)*log(g(1.0-r1,a,y,1.0)*g(r2,a,y,1.0))+g(1.0-r1,a,y,1)*g(1.0-r2,a,y,1.0)*log(g(1.0-r1,a,y,1.0)*g(1.0-r2,a,y,1.0)))/(4.0*(g(0.5,a,y,1.0)*g(0.5,a,y,1.0)*log(g(0.5,a,y,1.0)*g(0.5,a,y,1.0)))))**z;
!> h(r1,r2,a,y,z):=f1(r1,a,y,z)+f1(r2,a,y,z)-f2(r1,r2,a,y,z);
!> dhdr1(r1,r2,a,y,z):=diff(h(r1,r2,a,y,z),r1);
!> dhdr2(r1,r2,a,y,z):=diff(h(r1,r2,a,y,z),r2);
!> with_stdout("thimble.F",
!>     fortran_optimize([h,dhdr1,dhdr2],[h(r1,r2,a,y,z),dhdr1(r1,r2,a,y,z),dhdr2(r1,r2,a,y,z)]));
!>
!>
      subroutine wfn1_thimble_mermin(r1,r2,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      h     = 0.0d0
      dhdr1 = 0.0d0
      dhdr2 = 0.0d0
      t1 = -a**y
      t2 = (a+5.0d-1)**y+t1
      t3 = (a+1.0d+0)**y+t1
      t4 = 1/t3
      t5 = t2*t4
      t6 = 1/log(t5)
      t7 = (-r1)+a+1.0d+0
      t8 = t7**y+t1
      t9 = t4*t8
      t10 = (-r2)+a+1.0d+0
      t11 = t10**y+t1
      t12 = t4*t11
      t13 = log(t9*t12)
      t14 = r1+a
      t15 = t14**y+t1
      t16 = t4*t15
      t17 = log(t16*t12)
      t18 = r2+a
      t19 = t18**y+t1
      t20 = t4*t19
      t21 = log(t9*t20)
      t22 = log(t16*t20)
      t23 = t22*t16*t20+t21*t9*t20+t17*t16*t12+t13*t4*t8*t12
      t24 = ((t6*t23)/t5**2.0d+0)**z
      t25 = 1.25d-1**z
      t26 = 1/t2
      t27 = log(t9)
      t28 = log(t16)
      t29 = 1.0d+0*t28*t16+1.0d+0*t27*t9
      t30 = (t6*t26*t3*t29)**z
      t31 = 5.0d-1**z
      t32 = log(t12)
      t33 = log(t20)
      t34 = 1.0d+0*t33*t20+1.0d+0*t32*t12
      t35 = (t6*t26*t3*t34)**z
      t36 = 1/t23
      t37 = 1/t3**2
      t38 = y-1
      t39 = t7**t38
      t40 = t14**t38
      t41 = 1/t3**4
      t42 = t3/t8
      t43 = t11**2
      t44 = t3/t11
      t45 = t3/t15
      t46 = t19**2
      t47 = t3/t19
      t48 = t10**t38
      t49 = t8**2
      t50 = t15**2
      t51 = t18**t38
      h = t35*t31+t30*t31-t24*t25+h
      dhdr1 = (t30*(1.0d+0*t28*t4*t40*y+1.0d+0*t4*t40*y-1.0d+0*t27*t4*t3
     1   9*y-1.0d+0*t4*t39*y)*z*t31)/t29-t36*t24*(t41*t40*t15*t45*t46*t4
     2   7*y-t41*t8*t42*t39*t46*t47*y+t22*t37*t40*t19*y-t21*t37*t39*t19*
     3   y+t41*t40*t15*t45*t43*t44*y-t41*t8*t42*t39*t43*t44*y+t17*t37*t4
     4   0*t11*y-t13*t37*t39*t11*y)*z*t25+dhdr1
      dhdr2 = (t35*(1.0d+0*t33*t4*t51*y+1.0d+0*t4*t51*y-1.0d+0*t32*t4*t4
     1   8*y-1.0d+0*t4*t48*y)*z*t31)/t34-t36*t24*(t41*t50*t45*t51*t19*t4
     2   7*y+t41*t49*t42*t51*t19*t47*y+t22*t37*t15*t51*y+t21*t37*t8*t51*
     3   y-t41*t50*t45*t11*t44*t48*y-t41*t49*t42*t11*t44*t48*y-t17*t37*t
     4   15*t48*y-t13*t37*t8*t48*y)*z*t25+dhdr2
      end subroutine wfn1_thimble_mermin
c
c-----------------------------------------------------------------------
c
!> \brief Thimble function by repurposing SSF
!>
!> As the Mermin entropy based approach did not allow us to get the
!> entropy right (total energies and occupation numbers of H2 in a 
!> minimal basis were all wrong: total energy rises too slowly away
!> from equilibrium), we taking another approach here. 
!>
!> The approach used here is based on repurposing the SSF switching
!> function [1]. This switching function is modified by a transformation
!> of the coordinates \f$t(x=[0,1],y):->[0,1]\f$ given by \f$x^y\f$. The
!> transformed coordinates are transformed \f$u(x=[0,1]):->[-1,1]\f$ again
!> where u is a linear transformation.
!> Then the function \f$h(x=[-1,1]):->[-1,1]\f$ is applied. The timble
!> function is defined as \f$g(x)=h(x)*h(1-x)\f$. This result is then mapped
!> to the range [0,1] by \f$f(x)=\frac{(1+g(x))}{(1+g(1/2))}\f$.
!> Finally the thimble function overall is defined as 
!> \f$k(x,y)=f(x)*f(y)\f$.
!>
!> The switching function is defined as [1] (see Eq.(5)):
!> \f{eqnarray}{
!> h(x)&=&\frac{3}{2}x-\frac{1}{2}x^3
!> \f}
!>
!> Using Maxima to generate the thimble function and it's derivatives.
!>
!> This code was generated by running the following script throught
!> Maxima using the command line:
!>
!>    maxima -b thimble.mac
!> 
!> The content of thimble.mac is:
!>
!> optimprefix: t;
!> 
!> fortran_block(l,e) := block( [n : 0],
!>   for n:1 thru length(e) do
!>     fortran(l[n] = l[n] + e[n])
!>   );
!> 
!> fortran_optimize(l,e) := block(
!>   for p in rest(args(optimize(e))) do
!>     if op(p)=":" then fortran(apply("=",args(p)))
!>     else if listp(p) then fortran_block(l,p)
!>     else fortran(p)
!>   );
!> 
!> t(r,y):=r**y;
!> u(r):=2*r-1;
!> h(u):=(3.0/2.0)*u-(u**3)/2.0;
!> g(x,y):=(x+1)/(y+1);
!> 
!> s(r1,r2,a,y,z):=g(h(u(t(r1,y)))*h(u(t(1.0-r1,y))),h(u(t(0.5,y)))*h(u(t(0.5,y))))*g(h(u(t(r2,y)))*h(u(t(1.0-r2,y))),h(u(t(0.5,y)))*h(u(t(0.5,y))));
!> dsdr1(r1,r2,a,y,z):=diff(s(r1,r2,a,y,z),r1);
!> dsdr2(r1,r2,a,y,z):=diff(s(r1,r2,a,y,z),r2);
!> with_stdout("thimble.F",
!>     fortran_optimize([h,dhdr1,dhdr2],[s(r1,r2,a,y,z),dsdr1(r1,r2,a,y,z),dsdr2(r1,r2,a,y,z)]));
!>
!> [1] R.E. Stratmann, G.E. Scuseria, M.J. Frisch, "Achieving linear
!>     scaling in exchange-correlation density functional quadratures",
!>     Chemical Physics Letters (1996), Vol. 257, pp. 213-223, DOI:
!>     https://doi.org/10.1016/0009-2614(96)00600-8
!>
      subroutine wfn1_thimble_ssf(r1,r2,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      t1 = 1.0d+0-r1
      t2 = 2.0d0*t1**y-1.0d0
      t3 = 1.5d+0*t2-5.0d-1*t2**3
      t4 = 2.0d0*r1**y-1.0d0
      t5 = 1.5d+0*t4-5.0d-1*t4**3
      t6 = t3*t5+1.0d0
      t7 = 1.0d+0-r2
      t8 = 2.0d0*t7**y-1.0d0
      t9 = 1.5d+0*t8-5.0d-1*t8**3
      t10 = 2.0d0*r2**y-1.0d0
      t11 = 1.5d+0*t10-5.0d-1*t10**3
      t12 = t9*t11+1.0d0
      t13 = 2.0d0*5.0d-1**y-1.0d0
      t14 = 1.0d0/((1.5d+0*t13-5.0d-1*t13**3)**2+1.0d0)**2
      t15 = y-1.0d0
      t16 = t1**t15
      t17 = r1**t15
      t18 = t7**t15
      t19 = r2**t15
      h = t6*t12*t14+h
      dhdr1 = t12*(t3*(3.0d+0*t17*y-3.0d+0*t17*t4**2*y)+t5*(3.0d+0*t2**2
     1   *t16*y-3.0d+0*t16*y))*t14+dhdr1
      dhdr2 = t6*(t9*(3.0d+0*t19*y-3.0d+0*t19*t10**2*y)+t11*(3.0d+0*t8**
     1   2*t18*y-3.0d+0*t18*y))*t14+dhdr2
      end subroutine wfn1_thimble_ssf
c
c-----------------------------------------------------------------------
c
!> \brief Thimble inspired by Jacobi rotation
!>
!> Using Maxima to generate the thimble function and it's derivatives.
!>
!> This code was generated by running the following script throught
!> Maxima using the command line:
!>
!>    maxima -b cos.mac
!> 
!> The content of cos.mac is:
!>
!> optimprefix: t;
!> 
!> fortran_block(l,e) := block( [n : 0],
!>   for n:1 thru length(e) do
!>     fortran(l[n] = l[n] + e[n])
!>   );
!> 
!> fortran_optimize(l,e) := block(
!>   for p in rest(args(optimize(e))) do
!>     if op(p)=":" then fortran(apply("=",args(p)))
!>     else if listp(p) then fortran_block(l,p)
!>     else fortran(p)
!>   );
!> 
!> c(x):=cos(2*%pi*x);
!> h(r1,r2,y):=((1-c(r1)-c(r2)+c(r1)*c(r2))/(1-c(1/2)-c(1/2)+c(1/2)*c(1/2)))**y;
!> 
!> dhdr1(r1,r2,y):=diff(h(r1,r2,y),r1);
!> dhdr2(r1,r2,y):=diff(h(r1,r2,y),r2);
!> with_stdout("cos.F",
!>     fortran_optimize([h,dhdr1,dhdr2],[h(r1,r2,y),dhdr1(r1,r2,y),dhdr2(r1,r2,y)]));
!> 
!>
      subroutine wfn1_thimble_cos(r1,r2,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      tpi = acos(-1.0d0)
      t1 = 2*tpi*r1
      t2 = cos(t1)
      t3 = 2*tpi*r2
      t4 = cos(t3)
      t5 = t2*t4-t4-t2+1
      t6 = 1/4**y
      t7 = t5**(y-1)
      t8 = sin(t1)
      t9 = sin(t3)
      h = t5**y*t6
      dhdr1 = t7*(2*tpi*t8-2*tpi*t8*t4)*y*t6
      dhdr2 = t7*(2*tpi*t9-2*tpi*t2*t9)*y*t6
      end subroutine wfn1_thimble_cos
c
c-----------------------------------------------------------------------
c
!> \brief Thimble function based on an exponent
!>
!> Using Maxima to generate the thimble function and it's derivatives.
!>
!> This code was generated by running the following script throught
!> Maxima using the command line:
!>
!>    maxima -b spire.mac
!> 
!> The content of spire.mac is:
!>
!> optimprefix: t;
!> 
!> fortran_block(l,e) := block( [n : 0],
!>   for n:1 thru length(e) do
!>     fortran(l[n] = l[n] + e[n])
!>   );
!> 
!> fortran_optimize(l,e) := block(
!>   for p in rest(args(optimize(e))) do
!>     if op(p)=":" then fortran(apply("=",args(p)))
!>     else if listp(p) then fortran_block(l,p)
!>     else fortran(p)
!>   );
!> 
!> e(r,y):=exp(-y*abs(r-1/2));
!> f(r,y):=(e(r,y)-e(0,y))/(e(1/2,y)-e(0,y));
!> h(r1,r2,y):=f(r1,y)*f(r2,y);
!> 
!> dhdr1(r1,r2,y):=diff(h(r1,r2,y),r1);
!> dhdr2(r1,r2,y):=diff(h(r1,r2,y),r2);
!> with_stdout("spire.F",
!>     fortran_optimize([h,dhdr1,dhdr2],[h(r1,r2,y),dhdr1(r1,r2,y),dhdr2(r1,r2,y)]));
!> 
!>
      subroutine wfn1_thimble_spire(r1,r2,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      t1    = -1.0d0/exp(y/2.0d+0)
      t2    = 1.0d0/(t1+1.0d0)**2
      t3    = r1+(-1.0d+0)/2.0d+0
      t4    = abs(t3)
      t5    = exp(-t4*y)
      t6    = t5+t1
      t7    = r2+(-1.0d+0)/2.0d+0
      t8    = abs(t7)
      t9    = exp(-t8*y)
      t10   = t9+t1
      h     = t2*t6*t10
      dhdr1 = -(t3*y*t2*t5*t10)/t4
      dhdr2 = -(t7*y*t2*t6*t9)/t8
      end subroutine wfn1_thimble_spire
c
c-----------------------------------------------------------------------
c
!> \brief Thimble function based on a Gaussian
!>
!> Using Maxima to generate the thimble function and it's derivatives.
!>
!> This code was generated by running the following script throught
!> Maxima using the command line:
!>
!>    maxima -b gaussian.mac
!> 
!> The content of gaussian.mac is:
!>
!> optimprefix: t;
!> 
!> fortran_block(l,e) := block( [n : 0],
!>   for n:1 thru length(e) do
!>     fortran(l[n] = l[n] + e[n])
!>   );
!> 
!> fortran_optimize(l,e) := block(
!>   for p in rest(args(optimize(e))) do
!>     if op(p)=":" then fortran(apply("=",args(p)))
!>     else if listp(p) then fortran_block(l,p)
!>     else fortran(p)
!>   );
!> 
!> e(r,y):=exp(-y*(r-1/2)**2);
!> f(r,y):=(e(r,y)-e(0,y))/(e(1/2,y)-e(0,y));
!> h(r1,r2,y):=f(r1,y)*f(r2,y);
!> 
!> dhdr1(r1,r2,y):=diff(h(r1,r2,y),r1);
!> dhdr2(r1,r2,y):=diff(h(r1,r2,y),r2);
!> with_stdout("gaussian.F",
!>     fortran_optimize([h,dhdr1,dhdr2],[h(r1,r2,y),dhdr1(r1,r2,y),dhdr2(r1,r2,y)]));
!> 
!>
      subroutine wfn1_thimble_gaussian(r1,r2,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      t1 = -1.0d0/exp(y/4.0d+0)
      t2 = 1.0d0/(t1+1.0d0)**2
      t3 = r1+(-1.0d+0)/2.0d+0
      t4 = exp(-t3**2*y)
      t5 = t4+t1
      t6 = r2+(-1.0d+0)/2.0d+0
      t7 = exp(-t6**2*y)
      t8 = t7+t1
      h  = t2*t5*t8
      dhdr1 = -2.0d0*t3*y*t2*t4*t8
      dhdr2 = -2.0d0*t6*y*t2*t5*t7
      end subroutine wfn1_thimble_gaussian
c
c-----------------------------------------------------------------------
c
!> \brief Thimble function based on Mermin entropy
!>
!> Using Maxima to generate the thimble function and it's derivatives.
!>
!> This code was generated by running the following script throught
!> Maxima using the command line:
!>
!>    maxima -b thimble_better.mac
!> 
!> The content of thimble_better.mac is:
!>
!> optimprefix: t;
!> 
!> fortran_block(l,e) := block( [n : 0],
!>   for n:1 thru length(e) do
!>     fortran(l[n] = l[n] + e[n])
!>   );
!> 
!> fortran_optimize(l,e) := block(
!>   for p in rest(args(optimize(e))) do
!>     if op(p)=":" then fortran(apply("=",args(p)))
!>     else if listp(p) then fortran_block(l,p)
!>     else fortran(p)
!>   );
!> 
!> e(r):=(r*(1.0-r));
!> f(r,y):=(e(r)/e(1/2))**y;
!> h(r1,r2,y):=f(r1,y)*f(r2,y);
!> 
!> dhdr1(r1,r2,y):=diff(h(r1,r2,y),r1);
!> dhdr2(r1,r2,y):=diff(h(r1,r2,y),r2);
!> with_stdout("thimble_better.F",
!>     fortran_optimize([h,dhdr1,dhdr2],[h(r1,r2,y),dhdr1(r1,r2,y),dhdr2(r1,r2,y)]));
!> 
!>
      subroutine wfn1_thimble_no_e(r1,r2,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      t1 = 1.0d+0-r1
      t2 = (t1*r1)**y
      t3 = 1.0d+0-r2
      t4 = (t3*r2)**y
      t5 = 4.0d+0**(2*y)
      h = t2*t4*t5
      dhdr1 = ((1.0d+0-2*r1)*t2*t4*y*t5)/(t1*r1)
      dhdr2 = (t2*(1.0d+0-2*r2)*t4*y*t5)/(t3*r2)
      end subroutine wfn1_thimble_no_e
c
c-----------------------------------------------------------------------
c
!> \brief Thimble function based on Mermin entropy and orbital energies
!>
!> Using Maxima to generate the thimble function and it's derivatives.
!>
!> This code was generated by running the following script throught
!> Maxima using the command line:
!>
!>    maxima -b thimble_energy.mac
!> 
!> The content of thimble_energy.mac is:
!>
!> optimprefix: t;
!> 
!> fortran_block(l,e) := block( [n : 0],
!>   for n:1 thru length(e) do
!>     fortran(l[n] = l[n] + e[n])
!>   );
!> 
!> fortran_optimize(l,e) := block(
!>   for p in rest(args(optimize(e))) do
!>     if op(p)=":" then fortran(apply("=",args(p)))
!>     else if listp(p) then fortran_block(l,p)
!>     else fortran(p)
!>   );
!> 
!> d(r):=(r*(1.0-r));
!> f(r,y):=(d(r)/d(1/2))**y;
!> g(e,z):=exp(-z*e*e);
!> h(r1,r2,de,y,z):=f(r1,y)*f(r2,y)*g(de,z);
!> 
!> dhdr1(r1,r2,de,y,z):=diff(h(r1,r2,de,y,z),r1);
!> dhdr2(r1,r2,de,y,z):=diff(h(r1,r2,de,y,z),r2);
!> with_stdout("thimble_energy.F",
!>     fortran_optimize([h,dhdr1,dhdr2],[h(r1,r2,de,y,z),dhdr1(r1,r2,de,y,z),dhdr2(r1,r2,de,y,z)]));
!> 
!>
      subroutine wfn1_thimble_001(r1,r2,de,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      t1 = 1.0d+0-r1
      t2 = (t1*r1)**y
      t3 = 1.0d+0-r2
      t4 = (t3*r2)**y
      t5 = 4.0d+0**(2*y)
      t6 = exp(-de**2*z)
      h = t2*t4*t5*t6
      dhdr1 = ((1.0d+0-2*r1)*t2*t4*y*t5*t6)/(t1*r1)
      dhdr2 = (t2*(1.0d+0-2*r2)*t4*y*t5*t6)/(t3*r2)
      end subroutine wfn1_thimble_001
      subroutine wfn1_thimble_002(r1,r2,de,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      t1 = 1.0d0/(log(2.0d0)/2.0d+0+3.4657359027997264d-1)**(2*y)
      t2 = de**2
      t3 = abs(de)
      t4 = 1.0d0/(2.7d+1*t2*t3+3.0d+0*t3+8.1d+1*de**4+9.0d+0*t2+1.0d+0)
      t5 = 1.0d+0-r1
      t6 = log(t5)
      t7 = log(r1)
      t8 = (-r1*t7)-t6*t5
      t9 = t8**y
      t10 = 1.0d+0-r2
      t11 = log(t10)
      t12 = log(r2)
      t13 = (-r2*t12)-t11*t10
      t14 = t13**y
      t15 = y-1.0d0
      h = 1.0d+0*t1*t4*t9*t14
      dhdr1 = 1.0d+0*t1*t4*(t6-t7)*t8**t15*t14*y
      dhdr2 = 1.0d+0*t1*t4*t9*(t11-t12)*t13**t15*y
      end subroutine wfn1_thimble_002
      subroutine wfn1_thimble_003(r1,r2,de,a,y,z,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter a, controls gradient at r=0 and r=1
      double precision, intent(in)  :: a ! not used
!>    Parameter y, controls gradient at r=0 and r=1
      double precision, intent(in)  :: y
!>    Parameter z, controls curvature at r=1/2
      double precision, intent(in)  :: z ! not used
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      t1 = 1.0d+0-r1
      t2 = (t1*r1)**y
      t3 = 1.0d+0-r2
      t4 = (t3*r2)**y
      t5 = 4.0d+0**(2*y)
      t6 = exp(-abs(de)**1.31d+0*z)
c     t6 = exp(-abs(de)**1.21319d+0*z)
c     t6 = exp(-abs(de)**0.50d+0*z)
      h = t2*t4*t5*t6
      dhdr1 = ((1.0d+0-2*r1)*t2*t4*y*t5*t6)/(t1*r1)
      dhdr2 = (t2*(1.0d+0-2*r2)*t4*y*t5*t6)/(t3*r2)
      end subroutine wfn1_thimble_003
      subroutine wfn1_thimble_004(r1,r2,de,x,y1,y2,z1,z2,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter x, controls gradient at r=0 and r=1
!>    The power on the entropy factor
      double precision, intent(in)  :: x 
!>    Parameter y1, y2, the power in the exponents
      double precision, intent(in)  :: y1, y2
!>    Parameter z1, z2, the scale factor in the exponents
      double precision, intent(in)  :: z1, z2
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      h     = 0.0d0
      dhdr1 = 0.0d0
      dhdr2 = 0.0d0
c
      t1 = 1.0d+0-r1
      t2 = (t1*r1)**x
      t3 = 1.0d+0-r2
      t4 = (t3*r2)**x
      t5 = 4.0d+0**(2*x)
      t6 = abs(de)
      t7 = exp((-t6**y2*z2)-t6**y1*z1)
      h = t2*t4*t5*t7+h
      dhdr1 = ((1.0d+0-2*r1)*t2*t4*x*t5*t7)/(t1*r1)+dhdr1
      dhdr2 = (t2*(1.0d+0-2*r2)*t4*x*t5*t7)/(t3*r2)+dhdr2
      end subroutine wfn1_thimble_004
      subroutine wfn1_thimble_005(r1,r2,de,x,y1,y2,z1,z2,h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter x, controls gradient at r=0 and r=1
!>    The power on the entropy factor
      double precision, intent(in)  :: x 
!>    Parameter y1, y2, the power in the exponents
      double precision, intent(in)  :: y1, y2
!>    Parameter z1, z2, the scale factor in the exponents
      double precision, intent(in)  :: z1, z2
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      double precision :: gsl_sf_gamma
c
      h     = 0.0d0
      dhdr1 = 0.0d0
      dhdr2 = 0.0d0
c
      t1 = 1.0d+0-r1
      t2 = (t1*r1)**x
      t3 = 1.0d+0-r2
      t4 = (t3*r2)**x
      t5 = 4.0d+0**(2*x)
      t6 = abs(de)
#ifdef USE_GSL
      t7 = gsl_sf_gamma((z1*t6)**y1+2.0d+0)
      t8 = gsl_sf_gamma((z2*t6)**y2+2.0d+0)
      t9 = exp(-t8-t7+2.0d+0)
#else
      t7 = (z1*t6)**y1+1.0d+0
      t8 = (z2*t6)**y2+1.0d+0
      t9 = exp((-exp(t8*log(t8)))-exp(t7*log(t7))+2.0d+0)
#endif
      h = t2*t4*t5*t9+h
      dhdr1 = ((1.0d+0-2*r1)*t2*t4*x*t5*t9)/(t1*r1)+dhdr1
      dhdr2 = (t2*(1.0d+0-2*r2)*t4*x*t5*t9)/(t3*r2)+dhdr2
      end subroutine wfn1_thimble_005
      subroutine wfn1_thimble(r1,r2,de,x,
     &                        y1,y2,y3,y4,y5,
     &                        z1,z2,z3,z4,z5,
     &                        h,dhdr1,dhdr2)
      implicit double precision (t)
!>    Occupation number 1
      double precision, intent(in)  :: r1
!>    Occupation number 2
      double precision, intent(in)  :: r2
!>    Difference in orbital energy
      double precision, intent(in)  :: de
!>    Parameter x, controls gradient at r=0 and r=1
!>    The power on the entropy factor
      double precision, intent(in)  :: x 
!>    Parameter y1, y2, the power in the exponents
      double precision, intent(in)  :: y1, y2, y3, y4, y5
!>    Parameter z1, z2, the scale factor in the exponents
      double precision, intent(in)  :: z1, z2, z3, z4, z5
!>    Entropy
      double precision, intent(out) :: h
!>    Derivative of Entropy wrt. r1
      double precision, intent(out) :: dhdr1
!>    Derivative of Entropy wrt. r2
      double precision, intent(out) :: dhdr2
c
      h     = 0.0d0
      dhdr1 = 0.0d0
      dhdr2 = 0.0d0
c
      t0 = abs(de)
      t1 = 1.0d+0-r1
      t2 = (t1*r1)**x
      t3 = 1.0d+0-r2
      t4 = (t3*r2)**x
      t5 = 4.0d+0**(2.0d0*x)
      t6 = -(t0*z5)**y5
      t7 = -(t0*z4)**y4
      t8 = -(t0*z3)**y3
      t9 = -(t0*z2)**y2
      t10 = -(t0*z1)**y1
      t11 = exp(t6+t7+t8+t9+t10)
cDEBUG
      write(*,*)'abs(de)=',t0
      write(*,*)'z1,y1  =',z1,y1,t10
      write(*,*)'z2,y2  =',z2,y2,t9
      write(*,*)'z3,y3  =',z3,y3,t8
      write(*,*)'z4,y4  =',z4,y4,t7
      write(*,*)'z5,y5  =',z5,y5,t6
      write(*,*)'exp    =',t11
cDEBUG
      h = t2*t4*t5*t11+h
      dhdr1 = ((1.0d+0-2*r1)*t2*t4*x*t5*t11)/(t1*r1)+dhdr1
      dhdr2 = (t2*(1.0d+0-2*r2)*t4*x*t5*t11)/(t3*r2)+dhdr2
      end subroutine wfn1_thimble
c
c-----------------------------------------------------------------------
